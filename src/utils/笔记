setState的使用

class A extends React.Component {
    state= {
        count: 1
    }
}

test1 = () => {
    this.setState(state => ({count: state.count+1 }))
}

test2 = () => {
    const count = this.state.count +1;
    this.setState({
        count;
    })
}

test3 = () => {
    this.setState(state => ({count: state.count+1 }), ()=> {  //在状态更新且界面更新后回调
        console.log(this.state.count);
    })
}

setState()
// 更新状态是异步的还是同步的？
// 1. 执行setState()的位置？
//    在react控制的回调函数中：生命周期勾子/react监听事件回调
//    非react控制的异步回调函数中：定时器回调/原生事件监听回调/promise回调/...
// 2. 异步or同步
//    react相关回调： 异步
//    其他异步回调： 同步

/ react监听事件回调中,setState是异步更新状态 /
update1 = () => {
    console.log('update1 setState()之前',this.state.count);
    this.setState(state => ({
      count: state.count+1,
    }))
    console.log('update1 setState()之后',this.state.count);

}

如何得到异步更新的setState()
在setState()的callback回调函数中.
this.setState(state => ({
      count: state.count+1,
    })) 不会进行合并
const count = this.state.count +1;
    this.setState({
        count;
    }) 不会获取最新的state，更新会合并


1.Component存在的问题？
  1). 父组件重新render(), 当前组件也会重新执行render(),即使没有任何变化
  2). 当前组件setState()，重新执行render(),即使state没有任何变化。
2.解决Component存在的问题
  1). 原因: 组件的ShouldComponentUpdate()默认返回true,即使数据没有变化render()都会重新执行
  2). 方法1：重写ShouldComponentUpdate()，判断有数据变化返回true，否则返回false
  3). 方法2：使用PureComponent代替Component
  4). 一般都使用PureComponent来优化组件性能

ShouldComponentUpdate(nextProps, nextState){
    if(this.props.m1 === nextProps.m1 && this.state.m2 === nextState.m2)
    {
        return false;
    }else 
     return true;
}

更改state中的对象，此方法不会引起上面的更新：
test1 = () =< {
    const m1 = this.state.m1
    m1.count = 2
    this.setState ({m1})
}
另一种方法会引起更新
test1 = () =< {
    const m1 = this.state.m1
    m1.count = 2
    this.setState ({m1: {...m1}})
}

3.PureComponent的基本原理
  1 重写实现shouldComponentUpdate()
  2 对组件的新/旧state和props中的数据进行浅比较，如果都没有变化，返回false，否则返回true
  3 一旦shouldComponentUpdate()返回false不再执行用于更新的render
浅比较



分页列表
1). 纯前台分页
    请求获取数据： 一次获取所有数据，翻页时不需要再发请求
    请求接口: 不需要指定: 页码和每页的数量
    响应数据: 所有数据的数组
2). 基于后台的分页
    请求获取数据: 每次只获取当前页的数据，翻页时要发请求
    请求接口: 需要指定: 页码和每页的数量
    响应数据: 当前页数据的数组 + 总记录数(total)


//取出用户信息   
    const userData = JSON.parse(sessionStorage.getItem('userData'));
//设置用户信息
    sessionStorage.setItem('userData',JSON.stringify(item));


    {
        title: '所属角色',
        dataIndex: 'role_id',
        render: (role_id) => this.state.roles.find(role => role._id === role_id).name;
    }



//根据role的数组生成包含所有角色名的对象(属性名用角色id值)
 initRoleNames = (roles) => {
     const roleNames = roles.reduce((pre, role)=> {
      pre[role._id] = role.name;
      return pre
     },{})
     //保存
     this.roleNames = roleNames;
 }
 render: (role_id) =>  this.roleNames[role._id]


 删除指定用户
 deleteUser = (user) => {
     Modal.confirm({
         title: '确认删除${user.username}吗?',
         onOk: async() => {
             const result = await reqDeleteUser(user._id);
             if(result.status===0){
                 message.success('删除用户成功');
                 this.quert();
             }
         }

     })
 }

 
indexOf方法即可用于字符串也可用于数组,返回数组中序号或者是字符串中第几个开始的

.error-mag {
    visibility: hidden;
    position: absolute;
    top: 0;
    left: 0;
    text-align: center;
    height: 30px;
    width: 100%;
    background: #f60c1a;
    color: #ffffff;
    font-size: 16px;
    transform: translateY(-30px);
    transition: all .3s;
    &.show {
        visibility: hidden;
        transform: translateY(0);
    }
}

BrowserRouter 可以使用 this.props.history.push('/product/detail') 携带数据
HashRouter 则不可以携带数据

运行打包项目
1. 与服务端项目独立运行
问题： 存在ajax请求跨域问题
解决： nginx配置反路由器

2. 合并到服务端项目一起运行（即使用同一个端口）
不再有ajax请求跨域问题

3. 使用BrowserRouter的问题
a 问题：刷新某个路由路径时，会出现404的错误
b 原因：项目根路径后的path路径会被当作后台路由路径，去请求对应的后台路由，但没有
c 解决：使用自定义中间件去读取返回index页面展现.

